// TODO @robin to move this whole thing to es6
Discourse.Emoji = {};
// bump up this number to expire all emojis
Discourse.Emoji.ImageVersion = "0"

var emoji = <%= Emoji.standard.map(&:name).flatten.inspect %>;
var aliases = <%= Emoji.aliases.inspect.gsub("=>", ":") %>;

Discourse.Emoji.extendedEmoji = {};

var customEmojiCallbacks = [];
Discourse.Emoji.addCustomEmojis = function(cb) {
  customEmojiCallbacks.push(cb);
};

Discourse.Emoji.applyCustomEmojis = function() {
  var self = this;
  _.each(customEmojiCallbacks, function(cb) { cb.apply(self); });
};

Discourse.Emoji.list = function(){
  var list = emoji.slice(0);
  _.each(Discourse.Emoji.extendedEmoji, function(v,k){ list.push(k); });
  return list;
};


var emojiHash = {};
// add all default emojis
emoji.forEach(function(code){ emojiHash[code] = true; });
// and their aliases
for (var name in aliases) {
  aliases[name].forEach(function(alias) {
    emojiHash[alias] = true;
  });
}

Discourse.Emoji.unescape = function(string) {
  //this can be further improved by supporting matches of emoticons that don't begin with a colon
  if (Discourse.SiteSettings.enable_emoji && string.indexOf(":") >= 0) {
    string = string.replace(/\B:[^\s:]+:?\B/g, function(m) {
      var isEmoticon = !!Discourse.Emoji.translations[m],
            emoji = isEmoticon ? Discourse.Emoji.translations[m] : m.slice(1, m.length - 1),
            hasEndingColon = m.lastIndexOf(":") === m.length - 1,
            url = Discourse.Emoji.urlFor(emoji);
      return url && (isEmoticon || hasEndingColon) ? "<img src='" + url + "' title='" + emoji + "' alt='" + emoji + "' class='emoji'>" : m;
    });
  }

  return string;
};

Discourse.Emoji.urlFor = urlFor = function(code) {
  var url, set = Discourse.SiteSettings.emoji_set;

  code = code.toLowerCase();

  if(Discourse.Emoji.extendedEmoji.hasOwnProperty(code)) {
    url = Discourse.Emoji.extendedEmoji[code];
  }

  if(!url && emojiHash.hasOwnProperty(code)) {
    url = Discourse.getURL('/images/emoji/' + set + '/' + code + '.png');
  }

  if(url && url[0] !== 'h' && Discourse.CDN) {
    url = Discourse.CDN + url;
  }

  if(url){
    url = url + "?v=" + Discourse.Emoji.ImageVersion;
  }

  return url;
};

Discourse.Emoji.exists = function(code){
  code = code.toLowerCase();
  return !!(Discourse.Emoji.extendedEmoji.hasOwnProperty(code) || emojiHash.hasOwnProperty(code));
};

// Also support default emotions
var translations = {
  ':)'   : 'smile',
  ':-)'  : 'smile',
  ':('   : 'frowning',
  ':-('  : 'frowning',
  ';)'   : 'wink',
  ';-)'  : 'wink',
  ':\'(' : 'cry',
  ':\'-(': 'cry',
  ':-\'(': 'cry',
  ':p'   : 'stuck_out_tongue',
  ':P'   : 'stuck_out_tongue',
  ':-P'  : 'stuck_out_tongue',
  ':O'   : 'open_mouth',
  ':-O'  : 'open_mouth',
  ':D'   : 'smiley',
  ':-D'  : 'smiley',
  ':|'   : 'expressionless',
  ':-|'  : 'expressionless',
  ':/'   : 'confused',
  '8-)'  : 'sunglasses',
  ";P"   : 'stuck_out_tongue_winking_eye',
  ";-P"  : 'stuck_out_tongue_winking_eye',
  ":$"   : 'blush',
  ":-$"  : 'blush'
};

Discourse.Emoji.translations = translations;

var toSearch;
Discourse.Emoji.search = function(term, options) {
  var maxResults = (options && options["maxResults"]) || -1;
  if (maxResults === 0) { return []; }

  toSearch = toSearch || _.union(_.keys(emojiHash), _.keys(Discourse.Emoji.extendedEmoji)).sort();

  var i, results = [];

  var done = function() {
    return maxResults > 0 && results.length >= maxResults;
  }

  for (i=0; i < toSearch.length; i++) {
    if (toSearch[i].indexOf(term) === 0) {
      results.push(toSearch[i]);
      if(done()) { break; }
    }
  }

  if(!done()){
    for (i=0; i < toSearch.length; i++) {
      if (toSearch[i].indexOf(term) > 0) {
        results.push(toSearch[i]);
        if(done()) { break; }
      }
    }
  }

  return results;
};

